---
title: "Micro data preparation for paper - vulnerability"
author: "Ruben Tarne"
date: "28/05/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Micro Data Preparation

Before running the Markdown document with the article, this code is calculating the micro data set necessary. Be advised that these calculations take a lot of RAM, i.e. they were performed on a system with 16GB of RAM and did not go through when other programs were opened \# Micro Data

```{r sortingData, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}
library(here)
here::i_am("wealth-effect/Working paper drafts/3rd-Draft - Micro data preparation for paper - vulnerability.Rmd")
source(here::here("R code files\\R functions WP vulnerabilities.R"))


model_path <- "test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul_40percentShock" # "test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul" # # "test_Agent_data_0.23_0.515_0.457_2.195_71_0.923_0.833_0.977_PrecautionDisp"
data_vul_FTBSM <- calculate_agent_vulnerability(numberPeriods = 600, returnAll = TRUE , numberOfMonteCarloRuns = 1,consumptionData = TRUE, folder_name = model_path, wd = "wealth-effect\\Results\\")

sortingData_data_vul_FTBSM <- data.frame()
data_vul <- data_vul_FTBSM

for(j in 1:600){
  print(j)
  # j=188
  # build a data frame where one row is one agent
  sortingData <- tibble(Period=data_vul$periods[j],
                        MonthlyGrossTotalIncome = as.numeric(data_vul$MonthlyGrossTotalIncome_Data[j,]),
                        MonthlyDisposableIncome = as.numeric(data_vul$MonthlyDisposableIncome_Data[j,]),
                        MonthlyMortgagePayments = as.numeric(data_vul$MonthlyMortgagePayments_Data[j,]),
                        BankBalance=as.numeric(data_vul$BankBalance_Data[j,]),
                        NetHousingWealth=as.numeric(data_vul$NetHousingWealth_Data[j,]),
                        Debt=as.numeric(data_vul$Debt_Data[j,]),
                        Consumption=as.numeric(data_vul$Consumption_Data[j,]),
                        ConsIncome=as.numeric(data_vul$IncomeConsumption_Data[j,]),
                        ConsFWealth=as.numeric(data_vul$FinancialWealthConsumption_Data[j,]),
                        ConsHWealth=as.numeric(data_vul$HousingWealthConsumption_Data[j,]),
                        ConsDebt=as.numeric(data_vul$DebtConsumption_Data[j,]),
                        # ConsDelev=ConsumptionDeleveragedData[j,],
                        NHouses = as.numeric(data_vul$NHousesOwned_Data[j,]),
                        # Homeowner = homeOwnershipRateData[j,],
                        isBTL = as.numeric(data_vul$isBTL_Data[j,]),
                        isFTB = as.numeric(data_vul$isFTB_Data[j,]),
                        inFirstHome = as.numeric(data_vul$isInFirstHome_Data[j,]),
                        Age =  as.numeric(data_vul$Age_Data[j,]),
                        # NetTransactionRevenue = NetTransactionRevenue[j,],
                        # PrincipalRepSale = PrincipalRepSale[j,],
                        # PrincipalRepRegular = PrincipalRepRegular[j,],
                        # PrincipalRepIrregular = PrincipalRepIrregular[j,],
                        # NewCredit = NewCredit[j,],
                        # CashInjection = CashInjection[j,],
                        # PrincipalRepInheritance = PrincipalRepInheritance[j,],
                        DebtServiceToPreTaxIncome = MonthlyMortgagePayments / MonthlyGrossTotalIncome,
                        totalNetWealth = NetHousingWealth + BankBalance,
                        # TODO financial wealth inherited, housing wealth inherited, NOT debt!
                        # financial distress index (Ampudia et al. 2016)-> how many months can one pay the mortgage with its FW when it has a negative
                        # financial margin (gross total income - taxes - debt payments (i.e. monthylDisposableIncome + essential consumption) - basic living costs)
                        # this measure is not cleaned for only households with mortgage debt. This is implemented below. Also, not only negative FW get a value.
                        # Negative months indicate positive FM
                        # basic living costs as 40% of median income
                        MonthsOfMortgagePaymentsCovered_0.4 = BankBalance / (MonthlyDisposableIncome - 0.4*median(MonthlyGrossTotalIncome, na.rm = TRUE)),
                        MonthsOfMortgagePaymentsCovered_0.5 = BankBalance / (MonthlyDisposableIncome - 0.5*median(MonthlyGrossTotalIncome, na.rm = TRUE)),
                        MonthsOfMortgagePaymentsCovered_0.6 = BankBalance / (MonthlyDisposableIncome - 0.6*median(MonthlyGrossTotalIncome, na.rm = TRUE)),
                        # basic living costs as 70% of median income
                        MonthsOfMortgagePaymentsCovered_0.7 =BankBalance / (MonthlyDisposableIncome - 0.7*median(MonthlyGrossTotalIncome, na.rm = TRUE)),
                        id = as.numeric(data_vul$Id_Data[j,]),
                        vulnerable = case_when(MonthsOfMortgagePaymentsCovered_0.6 >-8 & MonthsOfMortgagePaymentsCovered_0.6 <0 & Debt <0 ~ TRUE, TRUE ~ FALSE),
                        FinVulSince = as.numeric(data_vul$FinVulSince_Data[j,]),
                        FinVulReason = as.character(data_vul$FinVulReason_Data[j,]),
                        ShockedMonthlyDisposableIncome = as.numeric(data_vul$ShockedMonthlyDisposableIncome[j,])
                        
  )

  sortingData_data_vul_FTBSM <- bind_rows(sortingData_data_vul_FTBSM, sortingData)
}

# load(here::here(file = "test_Agent_data_0.222_0.556_0.657_4_0.988_0.969_0.7_march2021.Rdata"))

out <- read_csv(here::here(paste0("wealth-effect\\Results\\", model_path, "\\Output-run", 1, ".csv")))
out_HPI_HPA <- out %>%
  select(`Model time`, `Sale HPI`, `Sale AnnualHPA`) 

sortingData_data_vul_FTBSM <-sortingData_data_vul_FTBSM %>%
  full_join(out_HPI_HPA, by = c("Period" = "Model time"))%>%
  # mutate(HPI = round(`Sale HPI`, digits = 1)) %>%
  mutate(agent = case_when(
    isBTL==1 & inFirstHome==0 & isFTB==0 ~ "BTL", 
    # isBTL ==0 & inFirstHome == 0 &isFTB==0 ~ "Mover", 
    # isFTB ==1 ~ "FirstTimeBuyer",
    # isBTL==1 &  isFTB==0 ~ "BTL", 
    NHouses>0 & isBTL == 0 & inFirstHome == 0 ~ "Owner-Occupier (not First Home)",
    inFirstHome==1 ~ "Owner-Occupier (First Home)", 
    NHouses==0 ~ "Renter"))%>%
  filter(!is.na(vulnerable))

######################### transactions
transactions <- read_csv(here::here(paste0("wealth-effect/Results/", model_path, "/Transactions-run1.csv")))
transactions_hpi <- transactions %>%
  left_join(out_HPI_HPA, by = "Model time")


saveRDS(sortingData_data_vul_FTBSM, file = here::here(paste0("Agent_data_", model_path, ".rds")))
saveRDS(transactions_hpi, file = here::here(paste0("transactions_", model_path,".rds")))
# load(here::here(paste0(model_path, ".RData")))
```

## Microdata for checking robustness of results when using different measures of finanical vulnerability

You can also embed plots, for example:

```{r differentAmpudia, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}
# in this part I want to classify the households causes for becoming vulnerable, independent of the Ampudia measure.
# Therefore, I want to extend the "sorting_data" table by columns indicating when the household bought the last property 
# if they were saving and when they last sold property.
# Then I should be able to build an extra column containing a string indicating "vulnerable by".. 
library(purrr)
library(here)
source(here::here("R code files\\R functions WP vulnerabilities.R"))
model_path <-"test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul_40percentShock" #"test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul"

sortingData_data_vul_FTBSM <- readRDS(file = here::here(paste0("Agent_data_", model_path, ".rds")))
transactions_hpi <- readRDS(file = here::here(paste0("transactions_", model_path,".rds")))

transactions_sale_hpi <- transactions_hpi %>%
  filter(transactionType == "sale")

medianGTI <- sortingData_data_vul_FTBSM %>%
  group_by(Period) %>%
  summarise(medianGrossTotalIncome = median(MonthlyGrossTotalIncome, na.rm = TRUE))

library("data.table")
gc()
sortingData_Vul_cause <- sortingData_data_vul_FTBSM %>%
  select (-MonthsOfMortgagePaymentsCovered_0.4, -MonthsOfMortgagePaymentsCovered_0.5, MonthsOfMortgagePaymentsCovered_0.6, MonthsOfMortgagePaymentsCovered_0.7)%>% #### USE THIS LINE ONLY IF YOU TAKE THIS FOR INCOME SHOCK 
  mutate(saving = MonthlyDisposableIncome  - Consumption)%>% # mutate(saving = MonthlyDisposableIncome +492.7 - Consumption)%>%
  left_join(medianGTI, by = "Period")%>%
  split(.$id)  %>%
  # the output here is a list for every id, and every id is joined with all its recorded transactions 
  # for every period. If a household purchased two houses (those could be in the future of any given period), 
  # this means 2 entries for each period.
  map(left_join, transactions_sale_hpi, by = c("id" = "buyerId"), simplify = TRUE)  %>% 
  # the output is still a list, now with additional column, whith "inf" for households without a sale 
  # (i.e. those that only rented, or are still in social housing)
  map(mutate, howLongAgo = case_when(is.na(`Model time`) ~ Inf, Period - `Model time` < 0 ~ Inf, TRUE ~ Period - `Model time`)) %>% 
  # to reduce the number of rows to 1 per id and period, select the most recent transaction for each
  # period and id
  lapply(filter, howLongAgo >= 0)  %>%
  # as the data is still split into a list for each id, grouping by period is enough to create
  # one row for each id and period (using the top_n function)
  map(group_by, Period) %>% 
  # the which.min function ensures that when several sales are Inf periods ago, this will only 
  # select one row, not all with Inf value
  map(slice, which.min(howLongAgo)) #  

saveRDS(sortingData_Vul_cause, file = here::here(paste0("Zwischenschritt_different_Ampudia_", model_path,".rds")))
#####################################
##################################### restart R and load newly calculated data frame
#####################################
```

Ab hier neu laden

```{r differentAmpudia2ndHalf, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}

library(purrr)
library(here)
source(here::here("R code files\\R functions WP vulnerabilities.R"))
model_path <- "test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul_40percentShock" #"test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul"
sortingData_Vul_cause <- readRDS(file = here::here(paste0("Zwischenschritt_different_Ampudia_", model_path,".rds")))


sortingData_Vul_cause <- sortingData_Vul_cause %>%
  # finally, the list has to be reassembled into a dataframe
  data.table::rbindlist(use.names = FALSE) %>%
  mutate(Financial_margin_calculated_0.6 = MonthlyDisposableIncome - 0.6 * medianGrossTotalIncome) %>%
  mutate(MonthsOf_MP_Covered_0.6_calculated = BankBalance / Financial_margin_calculated_0.6) %>%
  
  mutate(vulnerable_calc_0.6_8m = case_when(Debt < 0 & 
                                              MonthsOf_MP_Covered_0.6_calculated < 0 & 
                                              MonthsOf_MP_Covered_0.6_calculated >= -8 ~ TRUE, 
                                            TRUE~ FALSE))%>%
  mutate(vulnerable_calc_0.6_1m = case_when(Debt < 0 & 
                                              MonthsOf_MP_Covered_0.6_calculated < 0 & 
                                              MonthsOf_MP_Covered_0.6_calculated >= -1 ~ TRUE, 
                                            TRUE~ FALSE))%>%
  mutate(vulnerable_calc_0.6_24m = case_when(Debt < 0 & 
                                               MonthsOf_MP_Covered_0.6_calculated < 0 & 
                                               MonthsOf_MP_Covered_0.6_calculated >= -24 ~ TRUE, 
                                             TRUE~ FALSE))

# due to a bug in working with lag or shift functions and pipes I use base R here
sortingData_Vul_cause$vulnerable_calc_0.6_8m_LAGGED  <- lag(sortingData_Vul_cause$vulnerable_calc_0.6_8m)
sortingData_Vul_cause$vulnerable_calc_0.6_1m_LAGGED  <- lag(sortingData_Vul_cause$vulnerable_calc_0.6_1m)
sortingData_Vul_cause$vulnerable_calc_0.6_24m_LAGGED <- lag(sortingData_Vul_cause$vulnerable_calc_0.6_24m)
gc()

# as.data.frame is important for the fill-function
sortingData_Vul_cause <- as.data.frame(sortingData_Vul_cause) %>%
  select(Period, howLongAgo, `Model time`, Age, buyerAge,  
         vulnerable, FinVulSince, saving, agent, id, 
         BankBalance, 
         MonthlyGrossTotalIncome, MonthlyMortgagePayments,  MonthlyDisposableIncome,
         FinVulReason,
         vulnerable_calc_0.6_8m, vulnerable_calc_0.6_1m, vulnerable_calc_0.6_24m,
         vulnerable_calc_0.6_8m_LAGGED, vulnerable_calc_0.6_1m_LAGGED, vulnerable_calc_0.6_24m_LAGGED,
         ) %>%
  # howlongago is 1 here, as the mortgage payments (and therefore the status of vulnerability)
  # are only recorded at the beginning of t+1 after the transaction in t

  mutate(FinVulReason_calc_0.6_8m = case_when(vulnerable_calc_0.6_8m_LAGGED == vulnerable_calc_0.6_8m ~ as.character(NA),
                                              saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_calc_0.6_8m == TRUE ~ "dissaving",
                                              # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                              howLongAgo ==1 & vulnerable_calc_0.6_8m == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_calc_0.6_8m == TRUE)  ~ "purchase",
                                              # howLongAgo ==0 & vulnerable_calc_0.6_8m == TRUE  ~ "purchase",  
                                              vulnerable_calc_0.6_8m == FALSE ~ "not vulnerable",
                                              TRUE ~ "other")) %>%
  mutate(FinVulReason_calc_0.6_1m = case_when(vulnerable_calc_0.6_1m_LAGGED == vulnerable_calc_0.6_1m ~ as.character(NA),
                                              saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_calc_0.6_1m == TRUE ~ "dissaving",
                                              # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                              howLongAgo ==1 & vulnerable_calc_0.6_1m == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_calc_0.6_1m == TRUE)  ~ "purchase",
                                              # howLongAgo == 0 & vulnerable_calc_0.6_1m == TRUE ~ "purchase", 
                                              vulnerable_calc_0.6_1m == FALSE ~ "not vulnerable",
                                              TRUE ~ "other")) %>%
  mutate(FinVulReason_calc_0.6_24m = case_when(vulnerable_calc_0.6_24m_LAGGED == vulnerable_calc_0.6_24m ~ as.character(NA),
                                               saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_calc_0.6_24m == TRUE ~ "dissaving",
                                               # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                               howLongAgo ==1 & vulnerable_calc_0.6_24m == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_calc_0.6_24m == TRUE)  ~ "purchase",
                                               # howLongAgo ==0 & vulnerable_calc_0.6_24m == TRUE ~ "purchase",
                                               vulnerable_calc_0.6_24m == FALSE ~ "not vulnerable",
                                               TRUE ~ "other")) %>%
  # this realises when a field changed, and converts all NA's following that value to it

  fill(FinVulReason_calc_0.6_8m) %>%
  fill(FinVulReason_calc_0.6_1m) %>%
  fill(FinVulReason_calc_0.6_24m) 




sortingData_different_Ampudia <- sortingData_Vul_cause%>%
  filter(Period > 2300, Period <= 2600) %>%
  # mutate(same = case_when(FinVulReason_calc_0.7_8m == FinVulReason ~TRUE, TRUE~FALSE))%>%
  select(Period, howLongAgo, `Model time`, Age, buyerAge,  
         vulnerable, FinVulSince, saving, agent, id, 
         BankBalance, 
         MonthlyGrossTotalIncome, MonthlyMortgagePayments,  MonthlyDisposableIncome,
         vulnerable_calc_0.6_8m,  FinVulReason_calc_0.6_8m,
         vulnerable_calc_0.6_1m,  FinVulReason_calc_0.6_1m,
         vulnerable_calc_0.6_24m, FinVulReason_calc_0.6_24m,
         FinVulReason
         # same
         )

# save(sortingData_different_Ampudia, file = here::here(paste0(model_path,"_diffAmpudia.RData")))
saveRDS(sortingData_different_Ampudia, file = here::here(paste0("different_Ampudia_", model_path,".rds")))

```

Hier für die INCOME SHOCK !!!

```{r differentAmpudia2ndHalfIncomeShock, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}

library(purrr)
library(here)
source(here::here("R code files\\R functions WP vulnerabilities.R"))
model_path <- "test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul_40percentShock" #"test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul"
sortingData_Vul_cause <- readRDS(file = here::here(paste0("Zwischenschritt_different_Ampudia_", model_path,".rds")))


sortingData_Vul_cause <- sortingData_Vul_cause %>%
  # finally, the list has to be reassembled into a dataframe
  data.table::rbindlist(use.names = FALSE) %>%
  mutate(Financial_margin_calculated_shocked = ShockedMonthlyDisposableIncome - 0.6 * medianGrossTotalIncome ) %>%
  mutate(MonthsOf_MP_Covered_shocked_calculated = BankBalance / Financial_margin_calculated_shocked) %>%
  
  mutate(vulnerable_calc_shocked_8m = case_when(Debt < 0 & 
                                              MonthsOf_MP_Covered_shocked_calculated < 0 & 
                                              MonthsOf_MP_Covered_shocked_calculated >= -8 ~ TRUE, 
                                            TRUE~ FALSE))%>%
  mutate(vulnerable_calc_shocked_1m = case_when(Debt < 0 & 
                                              MonthsOf_MP_Covered_shocked_calculated < 0 & 
                                              MonthsOf_MP_Covered_shocked_calculated >= -1 ~ TRUE, 
                                            TRUE~ FALSE))%>%
  mutate(vulnerable_calc_shocked_24m = case_when(Debt < 0 & 
                                               MonthsOf_MP_Covered_shocked_calculated < 0 & 
                                               MonthsOf_MP_Covered_shocked_calculated >= -24 ~ TRUE, 
                                             TRUE~ FALSE))

# due to a bug in working with lag or shift functions and pipes I use base R here
sortingData_Vul_cause$vulnerable_calc_shocked_8m_LAGGED  <- lag(sortingData_Vul_cause$vulnerable_calc_shocked_8m)
sortingData_Vul_cause$vulnerable_calc_shocked_1m_LAGGED  <- lag(sortingData_Vul_cause$vulnerable_calc_shocked_1m)
sortingData_Vul_cause$vulnerable_calc_shocked_24m_LAGGED <- lag(sortingData_Vul_cause$vulnerable_calc_shocked_24m)
gc()

# as.data.frame is important for the fill-function
sortingData_Vul_cause <- as.data.frame(sortingData_Vul_cause) %>%
  select(Period, howLongAgo, `Model time`, Age, buyerAge,  
         vulnerable, FinVulSince, saving, agent, id, 
         BankBalance, 
         MonthlyGrossTotalIncome, MonthlyMortgagePayments,  MonthlyDisposableIncome,
         FinVulReason,
         vulnerable_calc_shocked_8m, vulnerable_calc_shocked_1m, vulnerable_calc_shocked_24m,
         vulnerable_calc_shocked_8m_LAGGED, vulnerable_calc_shocked_1m_LAGGED, vulnerable_calc_shocked_24m_LAGGED,
         ) %>%
  # howlongago is 1 here, as the mortgage payments (and therefore the status of vulnerability)
  # are only recorded at the beginning of t+1 after the transaction in t

  mutate(FinVulReason_calc_shocked_8m = case_when(vulnerable_calc_shocked_8m_LAGGED == vulnerable_calc_shocked_8m ~ as.character(NA),
                                              saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_calc_shocked_8m == TRUE ~ "dissaving",
                                              # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                              howLongAgo ==1 & vulnerable_calc_shocked_8m == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_calc_shocked_8m == TRUE)  ~ "purchase",
                                              # howLongAgo ==0 & vulnerable_calc_shocked_8m == TRUE  ~ "purchase",  
                                              vulnerable_calc_shocked_8m == FALSE ~ "not vulnerable",
                                              TRUE ~ "other")) %>%
  mutate(FinVulReason_calc_shocked_1m = case_when(vulnerable_calc_shocked_1m_LAGGED == vulnerable_calc_shocked_1m ~ as.character(NA),
                                              saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_calc_shocked_1m == TRUE ~ "dissaving",
                                              # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                              howLongAgo ==1 & vulnerable_calc_shocked_1m == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_calc_shocked_1m == TRUE)  ~ "purchase",
                                              # howLongAgo == 0 & vulnerable_calc_shocked_1m == TRUE ~ "purchase", 
                                              vulnerable_calc_shocked_1m == FALSE ~ "not vulnerable",
                                              TRUE ~ "other")) %>%
  mutate(FinVulReason_calc_shocked_24m = case_when(vulnerable_calc_shocked_24m_LAGGED == vulnerable_calc_shocked_24m ~ as.character(NA),
                                               saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_calc_shocked_24m == TRUE ~ "dissaving",
                                               # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                               howLongAgo ==1 & vulnerable_calc_shocked_24m == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_calc_shocked_24m == TRUE)  ~ "purchase",
                                               # howLongAgo ==0 & vulnerable_calc_shocked_24m == TRUE ~ "purchase",
                                               vulnerable_calc_shocked_24m == FALSE ~ "not vulnerable",
                                               TRUE ~ "other")) %>%
  # this realises when a field changed, and converts all NA's following that value to it

  fill(FinVulReason_calc_shocked_8m) %>%
  fill(FinVulReason_calc_shocked_1m) %>%
  fill(FinVulReason_calc_shocked_24m) 




sortingData_different_Ampudia <- sortingData_Vul_cause%>%
  filter(Period > 2300, Period <= 2600) %>%
  # mutate(same = case_when(FinVulReason_calc_0.7_8m == FinVulReason ~TRUE, TRUE~FALSE))%>%
  select(Period, howLongAgo, `Model time`, Age, buyerAge,  
         vulnerable, FinVulSince, saving, agent, id, 
         BankBalance, 
         MonthlyGrossTotalIncome, MonthlyMortgagePayments,  MonthlyDisposableIncome,
         vulnerable_calc_shocked_8m,  FinVulReason_calc_shocked_8m,
         vulnerable_calc_shocked_1m,  FinVulReason_calc_shocked_1m,
         vulnerable_calc_shocked_24m, FinVulReason_calc_shocked_24m,
         FinVulReason
         # same
         )

# save(sortingData_different_Ampudia, file = here::here(paste0(model_path,"_diffAmpudia.RData")))
saveRDS(sortingData_different_Ampudia, file = here::here(paste0("different_Ampudia_", model_path,".rds")))

```

Hier geht es nur noch um die 1500. Wenn oben die "zwischenSchritt"-Datei berechnet wurde, ist es nicht nötig diesen Block nochmal laufen zu lassen, da er identisch ist. Einfach überspringen.

```{r 1500MU, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}
# this code is almost identical tho that above, just using a different approach to defining financial vulnerability,
# namely having fewer than 1500 money units in their bank account

library(purrr)
library(here)
source(here::here("R code files\\R functions WP vulnerabilities.R"))
model_path <- "test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul"


sortingData_data_vul_FTBSM <- readRDS(file = here::here(paste0("Agent_data_", model_path, ".rds")))
transactions_hpi <- readRDS(file = here::here(paste0("transactions_", model_path,".rds")))

transactions_sale_hpi <- transactions_hpi %>%
  filter(transactionType == "sale")

medianGTI <- sortingData_data_vul_FTBSM %>%
  group_by(Period) %>%
  summarise(medianGrossTotalIncome = median(MonthlyGrossTotalIncome, na.rm = TRUE))

library("data.table")
gc()

sortingData_Vul_cause <- sortingData_data_vul_FTBSM %>%
  mutate(saving = MonthlyDisposableIncome - Consumption)%>%
  mutate(medianGTI = 2750)%>%
  # filter(Period > 2500, Period <= 2501) %>%
  # filter(id %in% c(41162:43000)) %>%
  split(.$id)  %>%
  # the output here is a list for every id, and every id is joined with all its recorded transactions 
  # for every period. If a household purchased two houses (those could be in the future of any given period), 
  # this means 2 entries for each period.
  map(left_join, transactions_sale_hpi, by = c("id" = "buyerId"), simplify = TRUE)  %>% 
  # the output is still a list, now with additional column, whith "inf" for households without a sale 
  # (i.e. those that only rented, or are still in social housing)
  map(mutate, howLongAgo = case_when(is.na(`Model time`) ~ Inf, Period - `Model time` < 0 ~ Inf, TRUE ~ Period - `Model time`)) %>% 
  # to reduce the number of rows to 1 per id and period, select the most recent transaction for each
  # period and id
  lapply(filter, howLongAgo >= 0)  %>%
  # as the data is still split into a list for each id, grouping by period is enough to create
  # one row for each id and period (using the top_n function)
  map(group_by, Period) %>% 
  # the which.min function ensures that when several sales are Inf periods ago, this will only 
  # select one row, not all with Inf value
  map(slice, which.min(howLongAgo)) #

saveRDS(sortingData_Vul_cause, file = here::here(paste0("Zwischenschritt_different_Ampudia_", model_path,".rds")))
#####################################
##################################### restart R and load newly calculated data frame
#####################################
```

```{r 1500MUSecondHalf, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}

library(purrr)
library(here)
source(here::here("R code files\\R functions WP vulnerabilities.R"))
model_path <- "test_Agent_data_0.069_0.641_0.496_2.08_70_0.985_0.753_0.916_Var4_60vul"

sortingData_Vul_cause <- readRDS(file = here::here(paste0("Zwischenschritt_different_Ampudia_", model_path,".rds"))) %>%
  # finally, the list has to be reassembled into a dataframe
  data.table::rbindlist(use.names = FALSE) %>%
  mutate(vulnerable_1500MU = case_when(BankBalance < 1500 ~ TRUE, TRUE ~ FALSE))


# due to a bug in working with lag or shift functions and pipes I use base R here
sortingData_Vul_cause$vulnerable_1500MU_LAGGED  <- lag(sortingData_Vul_cause$vulnerable_1500MU)


# as.data.frame is important for the fill-function
sortingData_Vul_cause <- as.data.frame(sortingData_Vul_cause) %>%
  # howlongago is 1 here, as the mortgage payments (and therefore the status of vulnerability)
  # are only recorded at the beginning of t+1 after the transaction in t
  mutate(FinVulReason_1500MU = case_when(vulnerable_1500MU_LAGGED == vulnerable_1500MU ~ as.character(NA),
                                        saving < 0 & howLongAgo != 0 & howLongAgo !=1 & vulnerable_1500MU == TRUE ~ "dissaving",
                                        # special condition to account for transaction being recorded at end of period, while Monhtly mortgage payments are not
                                        howLongAgo ==1 & vulnerable_1500MU == TRUE | (howLongAgo ==0 & MonthlyMortgagePayments == 0 & vulnerable_1500MU == TRUE)  ~ "purchase",  
                                        vulnerable_1500MU == FALSE ~ "not vulnerable",
                                        TRUE ~ "other")) %>%
  # this realises when a field changed, and converts all NA's following that value to it
  fill(FinVulReason_1500MU)

saveRDS(sortingData_Vul_cause, file = here::here(paste0("Vul_1500MU_", model_path, ".rds")))

```

```{r}

sortingData_data_vul_FTBSM <- readRDS(file = here::here(paste0("different_Ampudia_", model_path,".rds")))

sortingData_data_vul_FTBSM %>%
  filter ( Period == 2000) %>%
  # filter ( FinVulReason == "purchase") %>%
  # filter ( FinVulSince == 0) %>%
  # filter ( agent != "BTL" ) %>%
  # select(vulnerable,vulnerable_calc_0.6_8m) %>%
  # mutate(bothSame = case_when(vulnerable != vulnerable_calc_0.6_8m ~ FALSE, TRUE ~ TRUE)) %>%
  View()

alte_agentData %>%
  filter ( Period == 2000) %>%
  # filter ( FinVulReason == "purchase") %>%
  # filter ( FinVulSince == 0) %>%
  # filter ( agent != "BTL" ) %>%
  # select(vulnerable,vulnerable_calc_0.6_8m) %>%
  # mutate(bothSame = case_when(vulnerable != vulnerable_calc_0.6_8m ~ FALSE, TRUE ~ TRUE)) %>%
  View()



x <- "FinVulSince"
FinVulSince_Data_byHand <- read.csv(here::here(paste0(wd,folder_name, "\\",x, "-run", i, ".csv")), header = FALSE, strip.white = TRUE, col.names = paste0("C",seq_len(MaxColNumber)), fill = T)[,2:MaxColNumber]

```
